https://habr.com/ru/articles/578370/

# Типы данных

JavaScript имеет 8 встроенных типов данных:

1. `null`
    
2. `undefined`
    
3. `boolean`
    
4. `number`
    
5. `string`
    
6. `object`
    
7. `symbol`
    
8. `BigInt`

Вспомним простые значения в JS:

1. `null`
    
2. `string`
    
3. `boolean`
    
4. `number`
    
5. `symbol`
    

Комплексные значения:

1. Массивы
    
2. Объекты
    
3. Функции

## Строгое сравнение и сравнение с приведением типов

Обычно считается, что `===` использует “строгое” сравнение, и сравнивает типы, а `==` нет.

Если говорить более корректно, `==` позволяет делать приведение типов, тогда как `===` не разрешает.

**[Callback](https://ru.wikipedia.org/wiki/Callback_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5))** (колбэк, функция обратного вызова) — функция, которая вызывается в ответ на совершение некоторого события.



Simpleevent bus

sumplewidget



### Ад колбэков (Callback-hell)

 Скопировать ссылку "Ад колбэков (Callback-hell)"

Нагляднее всего его можно показать на примере.

Допустим, у нас есть ряд асинхронных задач, которые зависят друг от друга: то есть первая задача запускает по завершении вторую, вторая — третью и т. д.

```js
setTimeout(() => { setTimeout(() => { setTimeout(() => { setTimeout(() => { console.log('Hello!') }, 5000) }, 5000) }, 5000) }, 5000)
```

Если одна задача запускает другую, та — третью, и так далее, мы можем получить вот такую «башню» из обратных вызовов.

И такая башня может получиться где угодно. Если мы делаем несколько последовательных запросов к серверу, зависящих друг от друга, то это может выглядеть вот так:

```js
function request(url, onSuccess) {
  /*...*/
}

request('/api/users/1', function (user) {
  request(`/api/photos/${user.id}/`, function (photo) {
    request(`/api/crop/${photo.id}/`, function (response) {
      console.log(response)
    })
  })
})

```
Скопировать

Читать такое сложно, не говоря уже о тестировании, которое здесь становится очень накладным.

Решить эту проблему были призваны Промисы (Promise).


ACL идут в порядке

роль -> condition -> script


## В чем разница между let и var в JavaScript?

[](https://github.com/AndrewMosh/javascript_interview_cheatsheet?tab=readme-ov-file#%D0%B2-%D1%87%D0%B5%D0%BC-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D0%B0-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-let-%D0%B8-var-%D0%B2-javascript)

В JavaScript существуют два ключевых слова для объявления переменных: `let` и `var`. Вот основные различия между ними:

1. Область видимости (scope):
    
    - Переменные, объявленные с помощью `var`, имеют функциональную область видимости. Это означает, что они доступны внутри функции, в которой они объявлены, независимо от блока кода.
    - Переменные, объявленные с помощью `let`, имеют блочную область видимости. Они доступны только в пределах блока кода, в котором они объявлены.



## Что такое замыкания (closures) в JavaScript?

[](https://github.com/AndrewMosh/javascript_interview_cheatsheet?tab=readme-ov-file#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D1%8F-closures-%D0%B2-javascript)

Замыкания (closures) в JavaScript - это феномен, при котором функция сохраняет доступ к переменным из внешней области видимости, даже после завершения выполнения этой функции. Это позволяет функции "запомнить" значения переменных, существующих в том контексте, в котором она была создана.

### Пример замыкания:

[](https://github.com/AndrewMosh/javascript_interview_cheatsheet?tab=readme-ov-file#%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80-%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D1%8F)

```js
function createCounter() {
  let count = 0;

  return function () {
    count++;
    return count;
  };
}

const counter = createCounter();

console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3
```

В этом примере `createCounter()` возвращает функцию, которая имеет доступ к переменной `count`, хотя `createCounter()` уже выполнена. Это происходит из-за замыкания: функция "запоминает" контекст, в котором она была создана, и сохраняет доступ к переменным этого контекста.

Замыкания часто используются для создания частных переменных и данных, скрытых от глобальной области видимости, и для создания функций обратного вызова. **[⬆ Наверх](https://github.com/AndrewMosh/javascript_interview_cheatsheet?tab=readme-ov-file#%D1%81%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5)**

### Пример использования замыкания в функции обратного вызова:

[](https://github.com/AndrewMosh/javascript_interview_cheatsheet?tab=readme-ov-file#%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B2-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8-%D0%BE%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%BE%D0%B3%D0%BE-%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D0%B0)

```js
function doSomething(callback) {
  let result = 42;
  callback(result);
}

doSomething(function (data) {
  console.log("Получено:", data); // "Получено: 42"
});
```

Функция обратного вызова сохраняет доступ к переменной `result` благодаря замыканию.


1. **Что такое** `this`**?**
    
    `this` указывает на объект области видимости во время выполнения. По умолчанию `this` указывает на глобальный объект. В браузере выражение `this === window` будет истинно.

1. **В чем разница между** `Array.prototype.forEach` **и** `Array.prototype.map`**?**
    
    `Array.prototype.forEach` - это инструмент обхода цикла процедурно, а `Array.prototype.map` - функционально.
    
    `.forEach` просто проходится по массиву с выполнением переданного обратного вызова на каждой итерации, а `.map` создает и возвращает новый массив на основе исходного, выкладывая по кирпичику на каждой итерации.



**Пример использования `forEach`:**

javascript

Copy Code

```javascript
const numbers = [1, 2, 3];
numbers.forEach(num => {
  console.log(num * 2);
});
// Выведет 2, 4, 6
```

**Пример использования `map`:**

javascript

Copy Code

```javascript
const numbers = [1, 2, 3];
const doubledNumbers = numbers.map(num => num * 2);
console.log(doubledNumbers);
// Выведет [2, 4, 6]
```

Итак, выбирайте `forEach`, когда вам нужно просто выполнить какие-либо операции с элементами массива и нет необходимости формировать новый массив. Выбирайте `map`, когда вам необходимо получить новый массив как результат трансформации существующего массива.


1. **Что такое цикл событий? В чем разница между стеком вызовов и очередью задач?**
    
    Стек вызовов - это структура данных (первым вошел, последним вышел), используемая для отслеживания порядка выполнения функций в текущем контексте (области видимости).
    
    Очередь задач - это структура данных (первым вошел, первым вышел), используемая для отслеживания выполнения асинхронных функций, готовых оказаться в стеке вызовов.
    
    Цикл событий - это механизм, на каждом тике выполняющий функции из стека вызовов и, если он оказывается пустым, перемещающий задачи из очереди задач в стек вызовов для выполнения.



1. **В чем разница между** `let`**,** `const` **и** `var`**?**
    
    `var`
    
    - поднимается в начало области видимости функции при компиляции
        
    - объявляет переменную, которая может быть перезаписана
        
    - объявляет переменную, которая может быть переопределена
        
    
    `let`
    
    - поднимается в начало области видимости блока при компиляции
        
    - объявляет переменную, которая может быть перезаписана
        
    - объявляет переменную, которая не может быть переопределена
        
    
    `const`
    
    - поднимается в начало области видимости блока при компиляции
        
    - объявляет переменную, которая не может быть перезаписана или переопределена
        
2. **В чем разница между ES6** `class` **и ES5** `function constructor`**?**
    
    Классы, добавленные в стандарте EcmaScript 6, всего лишь синтаксический сахар поверх всем известных прототипов.
    
    В работе эти подходы отличаются уровнем абстракции, который ожидаемо выше у классов - разработчику не приходится напрямую работать с прототипами.